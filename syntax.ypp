%{
//bison -d -t syntax.y && flex lexer.l && gcc lex.yy.c syntax.tab.c -o test
#include <iostream>
#include <string>
#include "types.hpp"
#if defined (HAVE_LOCALE_H)
#  include <locale.h>
#endif

extern "C" int yylex();
extern "C" int yyparse (void);


/* **************************************************************** */
/*								    */
/*		  Let input be read from readline ().		    */
/*								    */
/* **************************************************************** */
//#define READLINE
#if defined (READLINE)

typedef union {
  FILE *file;
  char *string;
#if defined (BUFFERED_INPUT)
  int buffered_fd;
#endif
} INPUT_STREAM;

typedef int sh_cget_func_t __P((void));		/* sh_ivoidfunc_t */
typedef int sh_cunget_func_t __P((int));	/* sh_intfunc_t */

enum stream_type {st_none, st_stdin, st_stream, st_string, st_bstream};

typedef struct {
  enum stream_type type;
  char *name;
  INPUT_STREAM location;
  sh_cget_func_t *getter;
  sh_cunget_func_t *ungetter;
} BASH_INPUT;
extern BASH_INPUT bash_input;
//thanx to bash=)
extern int bash_readline_initialized;
extern void initialize_readline(void);
extern int stream_on_stack(enum stream_type);
extern void init_yy_io(sh_cget_func_t *, sh_cunget_func_t *, enum stream_type, const char *, INPUT_STREAM);

char *current_readline_prompt = (char *)NULL;
char *current_readline_line = (char *)NULL;
int current_readline_line_index = 0;

#if defined (READLINE)
static int yy_readline_get __P((void));
static int yy_readline_unget __P((int));
#endif

static int
yy_readline_get ()
{
  int line_len;
  unsigned char c;

  if (!current_readline_line)
    {
      if (!bash_readline_initialized)
	initialize_readline ();

      current_readline_line = readline (current_readline_prompt ?
      					  current_readline_prompt : "");


#if 0
      /* Reset the prompt to the decoded value of prompt_string_pointer. */
      reset_readline_prompt ();
#endif

      if (current_readline_line == 0)
	return (EOF);

      current_readline_line_index = 0;
      line_len = strlen (current_readline_line);

      current_readline_line = (char *)realloc (current_readline_line, 2 + line_len);
      current_readline_line[line_len++] = '\n';
      current_readline_line[line_len] = '\0';
    }

  if (current_readline_line[current_readline_line_index] == 0)
    {
      free (current_readline_line);
      current_readline_line = (char *)NULL;
      return (yy_readline_get ());
    }
  else
    {
      c = current_readline_line[current_readline_line_index++];
      return (c);
    }
}

static int
yy_readline_unget (int c)
{
  if (current_readline_line_index && current_readline_line)
    current_readline_line[--current_readline_line_index] = c;
  return (c);
}

void
with_input_from_stdin ()
{
  INPUT_STREAM location;

  if (bash_input.type != st_stdin && stream_on_stack (st_stdin) == 0)
    {
      location.string = current_readline_line;
      init_yy_io (yy_readline_get, yy_readline_unget,
		  st_stdin, "readline stdin", location);
    }
}

#endif

void yyerror(const char *str)
{
        std::cerr<<"error: "<<str<<"\n";
}
 
int yywrap()
{
        return 1;
} 
  
int main()
{
	std::cout<<"> ";
    yyparse();
    return 0;
} 

void print_function(func* f);

void print_object(std::vector<object>* obj)
{
    if(obj)
    {
        size_t i=0;
        for(auto it=obj->begin(); it!=obj->end(); it++)
        {
            if(!(it->is_object))//function
            {
                print_function(it->obj.f);
            }
            else
            {
                std::cout<<it->obj.obj_name;
            }
            if(i<obj->size()-1)
            {
                std::cout<<".";
            }
            i++;
        }
    };
}

void print_function(func* f)
{
    std::cout<<f->name<<"(";
    if(f->args)
    {
        size_t i=0;
        for(auto it=f->args->rbegin(); it!=f->args->rend(); it++)
        {
            switch(it->type_val)
            {
                case NUM_T:
                    std::cout<<it->val.num;
                break;
                
                case WORD_T:
                    std::cout<<it->val.str;
                break;
                
                case OBJECT:
                    print_object(it->val.obj);
                break;
                
                case FUNCTION:
                    print_function(it->val.f);
                break;
                
                case FILENAME_T:
                default:
                break;
            }
            if(i<f->args->size()-1)
            {
                std::cout<<", ";
            }
            i++;
        }
    }
    std::cout<<")";
}

void print_conveyor(std::vector<conveyor>* c)
{
	if(c)
    {
        size_t i=0;
        for(auto it=c->begin(); it!=c->end(); it++)
        {
            print_object(&it->command);
            if(i<c->size()-1)
            {
                switch (it->conv)
                {
                    case AND_CONV:
                        std::cout<<" && ";
                    break;
                    case OR_CONV:
                        std::cout<<" || ";
                    break;
                    case SEMICOLON_CONV:
                        std::cout<<"; ";
                    break;
                    default:
                    break;
                }
            }
            i++;
        }
    }
}

//#include "embedded_functions.hpp"


%}

%union {
double  num;
char    *str;
struct func             *func_val;//func args tree
std::vector<arg>        *seq;
std::vector<object>     *obj_list;//object tree
std::vector<conveyor>   *convey;//command tree
conveyor                *command_conveyor;
}

%token <num> NUM
%token <str> WORD
%type  <seq> func_args;
%type  <func_val>   function;
%type  <command_conveyor>       command;
%type  <convey>       finished_conveyor full_command full_conveyor  unfinished_conveyor
%type  <obj_list>     gen_command comm object_chains
%token DOT PLUS MINUS MULT DIV AND OR CONVEY ANYTHING FILENAME

%%


full_command: full_conveyor '\n'
			{
				if($1)
				{
					if($1->back().conv!=AND_CONV && $1->back().conv!=OR_CONV)
					{
						 //print full conveyor
						 print_conveyor($1);
						 std::cout<<"\n> ";
						 delete $1;
						 $$=nullptr;
					}
					else
					{
						std::cout<<"| ";
						$$=$1;
					}
				}
				else
				{
					std::cout<<"> ";
                    $$=$1;
				}
			}
			| full_command full_conveyor '\n'
			{
                std::vector<conveyor>* ret;
				if($2)
				{
					if($1)
					{
						if($1->back().conv==AND_CONV || $1->back().conv==OR_CONV)
						{//first conveyor isn't finished. concatenate both
							$2->insert( $2->begin(), $1->begin(), $1->end() );
                            //delete $1;
							ret=$2;
						}
					}
					if($2->back().conv==AND_CONV || $2->back().conv==OR_CONV)
					{//если вторая команда была незаконченным конвейером, просим пользователя его завершить
						std::cout<<"| ";
						ret=$2;
					}
					else
					{
						//print full conveyor
						print_conveyor($2);
						std::cout<<"\n> ";
						delete $2;
						ret=nullptr;
					}
				}
				else
				{//команды не было
					if($1 && ($1->back().conv==AND_CONV || $1->back().conv==OR_CONV))
					{//если первая команда была незаконченным конвейером, просим пользователя его завершить
						std::cout<<"| ";
						ret=$1;
					}
					else
					{//иначе просто просим ввести команду
						std::cout<<"> ";
						ret=nullptr;
					}
				}
				$$=ret;
			}
			;
			
full_conveyor: /*empty*/
			 {
				 $$=nullptr;
			 }
			 | unfinished_conveyor
			 | finished_conveyor
			 ;
			 
//no empty commands		 
finished_conveyor: finished_conveyor AND command
				 {
					 if(!$1->empty())
                     {
						$1->back().conv=AND_CONV;
					 }
                     $1->push_back(*$3);
                     //delete $3;
					 $$=$1;
				 }
				 | finished_conveyor OR command
				 {
					 if(!$1->empty())
                     {
						$1->back().conv=OR_CONV;
					 }
					 $1->push_back(*$3);
                     //delete $3;
					 $$=$1;
				 }
				 | command
                 {
                     std::vector<conveyor> *ret=new std::vector<conveyor>;
                     ret->push_back(*$1);
                     //delete $1;
                     $$=ret;
                 }
				 ;

//can have empties
unfinished_conveyor: finished_conveyor AND /*empty*/
				 {
					 if(!$1->empty())
                     {
						$1->back().conv=AND_CONV;
					 }
					 $$=$1;
				 }
				 | finished_conveyor OR /*empty*/
				 {
                     if(!$1->empty())
                     {
						$1->back().conv=OR_CONV;
					 }
					 $$=$1;
				 }
				 ;
	
command: comm
		{
			conveyor *c=new conveyor;
			c->command=*$1;
			c->conv=NO_CONV;
            $$=c;
		}
		| comm ';'
		{
			conveyor *c=new conveyor;
			c->command=*$1;
			c->conv=SEMICOLON_CONV;
			$$=c;
		}
		;

comm: gen_command
    | object_chains
    ;
    
object_chains: gen_command DOT comm
			{
                $1->insert($1->end(),$3->begin(), $3->end());
				$$=$1;
			}
			;

gen_command : WORD 
            {
                object com;
                com.is_object=true;
                com.obj.obj_name=$1;
                std::vector<object> *ret=new std::vector<object>;
                ret->push_back(com);
                $$=ret;
            }
			| function
            {
                object com;
                com.is_object=false;
                com.obj.f=$1;
                std::vector<object> *ret=new std::vector<object>;
                ret->push_back(com);
                $$=ret;
            }
            ;

function: WORD '(' func_args 
        {
            func *f=new func;
            f->name=$1;
            f->args=std::unique_ptr<std::vector<arg>>($3);
            $$=f;
        }
		| WORD '(' ')'  
        {
            func *f=new func;
            f->name=$1;
            f->args=nullptr;
            $$=f;
        }
		;
		
func_args :
			NUM ',' func_args 
            {  
                arg c;
                c.val.num=$1;
                c.type_val=NUM_T;
                $3->push_back(c);
                $$=$3;
            }
                                 
          | WORD   ',' func_args 
            {  
                arg c;
                c.val.str=$1;
                c.type_val=WORD_T;
                $3->push_back(c);
                $$=$3;
            }
                                                      
          | NUM ')'
            {  
                std::vector<arg> *curr_args=new std::vector<arg>;
                arg c;
                c.val.num=$1;
                c.type_val=NUM_T;
                curr_args->push_back(c);
                $$=curr_args;
            }
                                 
          | WORD   ')'
            {  
                std::vector<arg> *curr_args=new std::vector<arg>;
                arg c;
                c.val.str=$1;
                c.type_val=WORD_T;
                curr_args->push_back(c);
                $$=curr_args;
            }
                                 
          | function ',' func_args 
            {  
                arg c;
                c.val.f=$1;
                c.type_val=FUNCTION;
                $3->push_back(c);
                $$=$3;
            }
                                 
          | function ')'
            {  
                std::vector<arg> *curr_args=new std::vector<arg>;
                arg c;
                c.val.f=$1;
                c.type_val=FUNCTION;
                curr_args->push_back(c);
                $$=curr_args;
            }
          | object_chains ',' func_args
            {
                arg c;
                c.val.obj=$1;
                c.type_val=OBJECT;
                $3->push_back(c);
                $$=$3;
			}
		  | object_chains ')'
            { 
                std::vector<arg> *curr_args=new std::vector<arg>;
                arg c;
                c.val.obj=$1;
                c.type_val=OBJECT;
                curr_args->push_back(c);
                $$=curr_args;
            }
		    ;
%%
